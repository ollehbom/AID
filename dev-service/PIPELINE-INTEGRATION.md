# Pipeline Integration Guide

## Current State

The pipeline currently runs the dev agent directly in the workflow (lines 235-395 in `.github/workflows/pipeline.yml`).

## Changes Needed

Replace the entire `dev:` job with this:

```yaml
dev:
  needs: architect
  runs-on: ubuntu-latest
  permissions:
    contents: write
  steps:
    - uses: actions/checkout@v4
      with:
        ref: feature/${{ inputs.feature_id }}

    - name: Check if stage already complete
      id: check_status
      run: |
        if [ -f ".ai/pipeline/${{ inputs.feature_id }}.state" ]; then
          if grep -q "dev: ‚úì" .ai/pipeline/${{ inputs.feature_id }}.state; then
            echo "Stage already complete, skipping"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
        fi
        echo "skip=false" >> $GITHUB_OUTPUT

    - name: Call Dev Service
      if: steps.check_status.outputs.skip != 'true'
      run: |
        echo "üöÄ Calling Dev Service for feature: ${{ inputs.feature_id }}"

        # Call dev service (replace with your ngrok URL)
        RESPONSE=$(curl -s -X POST ${{ secrets.DEV_SERVICE_URL }}/dev-request \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ secrets.DEV_SERVICE_TOKEN }}" \
          -d "{
            \"feature_id\": \"${{ inputs.feature_id }}\",
            \"branch\": \"feature/${{ inputs.feature_id }}\",
            \"repository\": \"${{ github.repository }}\"
          }")

        echo "Response: $RESPONSE"

        # Check if request was accepted
        if echo "$RESPONSE" | grep -q '"status":"accepted"'; then
          echo "‚úÖ Dev service accepted the request"
        else
          echo "‚ùå Dev service rejected the request"
          exit 1
        fi

    - name: Wait for Dev Service to complete
      if: steps.check_status.outputs.skip != 'true'
      run: |
        echo "‚è≥ Waiting for dev service to complete implementation..."

        MAX_WAIT=1800  # 30 minutes
        ELAPSED=0
        INTERVAL=30

        while [ $ELAPSED -lt $MAX_WAIT ]; do
          # Pull latest changes from feature branch
          git pull origin feature/${{ inputs.feature_id }} || true
          
          # Check if dev service has committed changes
          if git log --since="1 minute ago" --author="Dev Service Bot" --oneline | grep -q "Feature ${{ inputs.feature_id }}"; then
            echo "‚úÖ Dev service completed - new commit detected"
            break
          fi
          
          # Alternative: Check for specific file that indicates completion
          if [ -f ".ai/pipeline/${{ inputs.feature_id }}.dev-complete" ]; then
            echo "‚úÖ Dev service marked as complete"
            break
          fi
          
          echo "Still waiting... (${ELAPSED}s / ${MAX_WAIT}s)"
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
        done

        if [ $ELAPSED -ge $MAX_WAIT ]; then
          echo "‚è∞ Timeout waiting for dev service"
          echo "Check dev service logs for errors"
          exit 1
        fi

    - name: Pull final changes
      if: steps.check_status.outputs.skip != 'true'
      run: |
        git pull origin feature/${{ inputs.feature_id }}

    - name: Validate build commands exist
      if: steps.check_status.outputs.skip != 'true'
      run: |
        BUILD_FILE=".ai/pipeline/${{ inputs.feature_id }}.build.json"

        if [ ! -f "$BUILD_FILE" ]; then
          echo "‚ö†Ô∏è  No build file generated by dev service"
          echo "Dev service may have failed"
          exit 1
        fi

        echo "‚úÖ Build commands file found"
        cat "$BUILD_FILE"

    - name: Update pipeline state
      if: steps.check_status.outputs.skip != 'true'
      run: |
        sed -i 's/status:.*/status: dev_complete/' .ai/pipeline/${{ inputs.feature_id }}.state
        sed -i 's/dev: .*/dev: ‚úì/' .ai/pipeline/${{ inputs.feature_id }}.state

        git config user.name "Pipeline Bot"
        git config user.email "pipeline@aid.local"
        git add .ai/pipeline/
        git commit -m "Dev: ${{ inputs.feature_id }} stage complete (via dev service)" || echo "No changes"
        git push
```

## Required GitHub Secrets

Add these to your repository secrets (Settings ‚Üí Secrets and variables ‚Üí Actions):

1. **`DEV_SERVICE_URL`**
   - Value: Your ngrok URL (e.g., `https://abc123.ngrok.io`)
   - Update this when ngrok restarts with a new URL

2. **`DEV_SERVICE_TOKEN`**
   - Value: `my-secret-token-12345` (same as in dev-service/.env)

## Testing the Integration

1. **Start dev service**:

   ```bash
   cd dev-service
   python app.py
   ```

2. **Start ngrok** (in another terminal):

   ```bash
   ngrok http 8080
   # Copy the HTTPS URL (e.g., https://abc123.ngrok.io)
   ```

3. **Update GitHub secret**:
   - Go to repository Settings ‚Üí Secrets ‚Üí Actions
   - Add or update `DEV_SERVICE_URL` with your ngrok URL

4. **Test with a feature**:

   ```bash
   gh workflow run pipeline.yml -f feature_id=test-dev-service
   ```

5. **Monitor**:
   - Dev service terminal: See incoming requests and build progress
   - Pipeline logs: See waiting and completion status

## Benefits of This Approach

- ‚úÖ Persistent dev environment (no state loss)
- ‚úÖ Iterative build loop (auto-fixes build errors)
- ‚úÖ Faster (no workflow queue, setup time)
- ‚úÖ Can handle multiple features in parallel
- ‚úÖ Error context preserved between attempts
- ‚úÖ Local development/debugging easier

## Rollback Plan

If dev service has issues, you can quickly revert to the original approach by:

1. Commenting out the dev service call
2. Re-enabling the "Run Dev Agent" step
3. Pushing the change

The build validation and QA stages remain unchanged, so they'll still validate whatever code was generated.
