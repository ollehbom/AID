# Technical Specification: Initial Core React Application (error-fix-1770411297669)

## Architecture Overview
The application will be a client-side rendered Single Page Application (SPA) built with React. It will be bundled using Vite and deployed as static assets to a Content Delivery Network (CDN). User authentication will be handled via Google OAuth, with the frontend redirecting to Google for authentication and then receiving an ID token. This ID token will be sent to a dedicated backend API endpoint for validation and to retrieve an application-specific JWT (JSON Web Token). All subsequent authenticated requests to the backend will use this JWT. The application will consume RESTful APIs from the backend for data retrieval.

## Components
-   **`App.tsx`**: The root component, responsible for routing and global context providers (e.g., `AuthContext`, `DesignSystemProvider`).
-   **`AuthContext.tsx`**: A React Context provider to manage the user's authentication state (logged in/out, user data, access token). It will handle token storage and retrieval.
-   **`DesignSystemProvider.tsx`**: Integrates Shadcn UI's theming and context, ensuring consistent styling across the application.
-   **`GoogleLoginScreen.tsx`**: A dedicated component for the login page, displaying the "Sign in with Google" button. It will manage its own loading and error states during the authentication initiation.
-   **`Dashboard.tsx`**: The main dashboard component, responsible for fetching and displaying initial mock content or actual user data. It will orchestrate sub-components for different dashboard widgets.
-   **`ProtectedRoute.tsx`**: A higher-order component or custom hook to guard routes, redirecting unauthenticated users to the login screen.
-   **Shadcn UI Components**: Utilized for all UI elements (buttons, cards, inputs, dialogs, etc.) to ensure consistency and accelerate development.

## Data Models

```json
{
  "User": {
    "id": "string",
    "name": "string",
    "email": "string",
    "avatarUrl": "string"
  },
  "AuthToken": {
    "accessToken": "string",
    "expiresAt": "number" // Unix timestamp
  },
  "DashboardData": {
    "projects": [
      "string" // e.g., "Project Alpha"
    ],
    "tasks": [
      "string" // e.g., "Task 1 (due tomorrow)"
    ]
  }
}
```

## APIs

### Authentication API (Backend)
-   **Endpoint**: `POST /api/auth/google/callback`
-   **Purpose**: Receives the Google ID token from the frontend, validates it with Google, creates/retrieves the user in the application's database, and issues an application-specific JWT.
-   **Request Format**:
    ```json
    {
      "idToken": "<Google_ID_Token_String>"
    }
    ```
-   **Response Format (Success 200 OK)**:
    ```json
    {
      "accessToken": "<Application_JWT>",
      "user": {
        "id": "user-123",
        "name": "John Doe",
        "email": "john.doe@example.com",
        "avatarUrl": "https://example.com/avatar.jpg"
      }
    }
    ```
-   **Error Handling**: Returns 400 for invalid token, 401 for unauthorized (e.g., account not provisioned), 500 for server errors.

### Dashboard Data API (Backend)
-   **Endpoint**: `GET /api/dashboard`
-   **Purpose**: Fetches the initial data to populate the user's dashboard.
-   **Authentication Requirements**: Requires `Authorization: Bearer <accessToken>` header with a valid application JWT.
-   **Request Format**: No body.
-   **Response Format (Success 200 OK)**:
    ```json
    {
      "projects": [
        "Project Alpha",
        "Project Beta"
      ],
      "tasks": [
        "Task 1 (due tomorrow)",
        "Task 2 (due next week)"
      ]
    }
    ```
-   **Error Handling**: Returns 401 for unauthorized access, 500 for server errors.

## Infrastructure
-   **Frontend Hosting**: Static site hosting on a Content Delivery Network (CDN) (e.g., AWS S3 + CloudFront, Vercel, Netlify) for high availability, low latency, and scalability.
-   **DNS**: Proper domain configuration (A records, CNAMEs) pointing to the CDN distribution.
-   **Backend Services**: Existing or new backend service(s) to support the `/api/auth/google/callback` and `/api/dashboard` endpoints. This backend will handle Google ID token validation, user management, and data storage.
-   **SSL/TLS**: Mandatory HTTPS for all frontend and backend communication.

## Testing Strategy
-   **Unit Tests**: Jest and React Testing Library will be used for individual React components (e.g., `GoogleLoginScreen`, `Dashboard` layout, utility functions). Focus on component rendering, prop handling, and event interactions.
-   **Integration Tests**: Test the authentication flow from clicking "Sign in with Google" to receiving and storing the JWT. This will involve mocking Google's redirect and potentially mocking backend API responses. Also, test data fetching and display on the dashboard.
-   **End-to-End (E2E) Tests**: Cypress or Playwright will be used to simulate critical user journeys (e.g., navigating to login, successful Google login, viewing dashboard content). This ensures the entire application stack works together.
-   **Visual Regression Testing (Optional for MVP)**: Tools like Storybook with Chromatic or Percy can be considered in later stages to ensure consistent UI across changes, especially with Shadcn UI customizations.

## Deployment
-   **CI/CD Pipeline**: A continuous integration/continuous deployment pipeline will be established to automate the build, test, and deployment process.
    1.  **Build**: Upon code commit to the main branch, the React application will be built (e.g., `vite build`).
    2.  **Test**: Unit and integration tests will run automatically.
    3.  **Deploy**: On successful tests, the compiled static assets will be uploaded to the CDN.
-   **Rollout Strategy**: Direct deployment to production. For future features, a canary or blue/green deployment strategy can be considered with feature flags.
-   **Feature Flags**: Not strictly required for the initial MVP, but the architecture should allow for easy integration of feature flag libraries for future incremental releases.
-   **Monitoring and Alerts**: Implement client-side error logging (e.g., Sentry, LogRocket) to capture JavaScript errors and user session issues. Integrate performance monitoring (e.g., Google Lighthouse CI, Web Vitals reporting) to track frontend performance metrics.
