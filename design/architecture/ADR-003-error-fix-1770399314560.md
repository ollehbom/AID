# ADR-003: Foundational React App with Google Login and Dashboard

## Status
Proposed

## Context
The current product lacks a foundational application infrastructure, preventing initial user onboarding and the testing of any product features. There is an immediate need to establish a core React application with a modern design system, secure Google login, and a basic dashboard. This foundation is critical for validating core product beliefs, enabling user interaction, and providing a consistent platform for future development.

## Decision Drivers
-   **Scale**: The initial implementation targets internal test users but must be designed to scale efficiently for future growth (potential 1K-100K+ users). The chosen architecture should not introduce early scaling bottlenecks.
-   **Team expertise**: The team is proficient in React and aims for modern cloud development practices. The chosen technologies should align with efficient development and operational capabilities.
-   **Budget**: The initial hosting budget is constrained (MVP phase), requiring cost-effective solutions that scale with demand without incurring high fixed costs.
-   **Primary concerns**: Security (especially for authentication), reliability (application uptime and robust error handling), performance (fast initial load and responsive UI), and operational excellence (ease of deployment, monitoring, and maintenance) are paramount.

## Options Considered

### Option 1: Monolithic Backend + Traditional Frontend Hosting
**Description**: A single backend server (e.g., Node.js/Express, Python/Django) serving both API endpoints and potentially the static React assets, deployed on a traditional VM or container service.

**Pros:**
-   Simpler initial deployment for a small team (single codebase/repository, less infrastructure to manage).
-   Easier local development setup.

**Cons:**
-   Scaling bottlenecks: Backend compute resources are tightly coupled, making independent scaling of API and UI problematic.
-   Higher operational overhead: Requires manual server management, patching, and scaling configuration.
-   Less flexible for future microservices or specialized AI/ML workloads.
-   Potential for slower global content delivery without separate CDN setup.

### Option 2: Decoupled Serverless Backend + CDN Hosted Frontend (Chosen)
**Description**: A static React frontend hosted on a Content Delivery Network (CDN) with a separate serverless backend (e.g., AWS Lambda + API Gateway, Azure Functions, Google Cloud Functions) handling API requests, including authentication. User data is stored in a managed database service.

**Pros:**
-   **High Scalability**: Frontend scales globally with CDN. Backend scales automatically with serverless functions, handling variable loads efficiently.
-   **Low Operational Overhead**: Managed services reduce server maintenance, patching, and infrastructure management.
-   **Cost-Effective**: Pay-per-execution for serverless functions and usage-based pricing for CDN are ideal for MVP and variable traffic patterns.
-   **High Availability**: Inherently provided by CDNs and serverless platforms.
-   **Performance**: Fast static asset delivery via CDN, reduced latency for users globally.
-   **Security**: Clear separation of concerns, easier to apply Zero Trust principles, managed services handle many underlying security aspects.
-   **Flexibility**: Aligns well with future microservices architecture and integration of specialized AI/ML services.

**Cons:**
-   Increased initial setup complexity compared to a monolith (separate deployment pipelines, infrastructure as code).
-   Debugging distributed systems can be more challenging.
-   Potential for cold start latency in serverless functions (though less critical for initial low usage).
-   Potential vendor lock-in with specific cloud serverless platforms.

## Decision
We will implement a decoupled architecture with a static React frontend hosted on a Content Delivery Network (CDN) and a serverless backend for authentication and API services. User profiles and related data will be stored in a managed relational database service. This approach provides a robust, scalable, and cost-effective foundation that aligns with our long-term architectural goals.

## Consequences

**Positive:**
-   **Enhanced Scalability & Reliability**: The system is designed to handle significant user growth and traffic spikes with minimal intervention, offering high availability by design.
-   **Optimized Performance**: Users will experience fast load times and a responsive interface due to CDN asset delivery and efficient backend processing.
-   **Reduced Operational Costs**: Lower infrastructure management overhead and pay-as-you-go pricing for serverless components will keep costs low during the MVP phase and scale efficiently.
-   **Improved Security Posture**: Clear separation of frontend and backend, secure Google OAuth flow (PKCE), and leveraging managed services with built-in security features.
-   **Future Flexibility**: Provides a solid foundation for integrating additional microservices and AI/ML capabilities without major architectural overhauls.

**Negative:**
-   **Increased Initial Setup Complexity**: Setting up CI/CD pipelines, IaC, and configuring multiple cloud services requires more upfront effort than a monolithic approach.
-   **Distributed System Debugging**: Troubleshooting issues across decoupled services can be more complex.

**Risks:**
-   **Cloud Vendor Lock-in**: Deep integration with a specific cloud provider's serverless ecosystem could make migration to another cloud more challenging in the future.
-   **Security Misconfigurations**: While managed services enhance security, misconfigurations of API Gateway, Lambda functions, or database access remain a risk if not properly managed.
-   **Cold Start Latency**: For very infrequent API calls, serverless functions might experience a slight delay due to cold starts, though this is expected to be minimal for initial usage.

## Implementation Guidance
-   **Frontend**: Develop using React and Shadcn UI. Deploy static assets to an AWS S3 bucket configured for web hosting, fronted by AWS CloudFront for global CDN delivery and HTTPS termination.
-   **Backend**: Implement authentication and user management logic using AWS Lambda functions, exposed via AWS API Gateway as RESTful endpoints.
-   **Authentication**: Utilize Google OAuth 2.0 with the PKCE (Proof Key for Code Exchange) flow for client-side authorization. The backend must verify Google-issued tokens and manage application-specific sessions (e.g., secure, HTTP-only cookies or JWTs).
-   **Database**: Provision a managed PostgreSQL database (e.g., AWS RDS for PostgreSQL) for storing user profiles (ID, Google ID, email, name, timestamps).
-   **Infrastructure as Code (IaC)**: Use Terraform or AWS CloudFormation to define and manage all cloud resources (S3, CloudFront, Lambda, API Gateway, RDS, DNS records).
-   **Secrets Management**: Store API keys, database credentials, and other sensitive information securely using AWS Secrets Manager or similar cloud-native secret management services.
-   **Monitoring & Logging**: Implement centralized logging (e.g., AWS CloudWatch Logs) for Lambda functions and API Gateway. Set up CloudWatch metrics and alarms for critical service health indicators. Integrate frontend error tracking (e.g., Sentry) for client-side issues.
-   **CI/CD**: Establish separate automated CI/CD pipelines for frontend (build, test, deploy to S3/CloudFront) and backend (build, test, deploy to Lambda/API Gateway) using tools like GitHub Actions, GitLab CI, or AWS CodePipeline.
